# -*- coding: utf-8 -*-
"""IN_II_st_II_rok_Py_2

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/120pRUIECVDKLcrrk9niv6WY4gVmb2Ixn
"""

# Tic-Tac-Toe w Pythonie z użyciem klas

# Klasa reprezentująca planszę gry w kółko-krzyżyk.
# Przechowuje stan planszy i dostarcza metody do jej obsługi.
class Board:

    def __init__(self):
        self.board = [[' ' for _ in range(3)] for _ in range(3)]

    def print_board(self):
        # Wyświetla aktualny stan planszy.
        print("\n")
        for row in self.board:
            print(" | ".join(row))
            print("-" * 5)
        print("\n")

    def is_full(self):
        # Sprawdza, czy plansza jest pełna.
        return all(cell != ' ' for row in self.board for cell in row)

    def update_cell(self, row, col, player):
        # Aktualizuje zawartość komórki planszy.
        self.board[row][col] = player

    def is_cell_empty(self, row, col):
        # Sprawdza, czy dana komórka planszy jest pusta.
        return self.board[row][col] == ' '

    def check_winner(self, player):
        # Sprawdza, czy dany gracz wygrał.
        # Sprawdzanie wierszy, kolumn i przekątnych w celu znalezienia wygranej
        for row in self.board:
            if row.count(player) == 3:
                return True
        for col in range(3):
            if [self.board[row][col] for row in range(3)].count(player) == 3:
                return True
        if [self.board[i][i] for i in range(3)].count(player) == 3:
            return True
        if [self.board[i][2 - i] for i in range(3)].count(player) == 3:
            return True
        return False

# Klasa reprezentująca grę w kółko-krzyżyk.
# Zarządza przebiegiem gry, kolejnością graczy i warunkami zakończenia.
class Game:

    def __init__(self):
        self.board = Board()
        self.players = ['X', 'O']
        self.turn = 0

    def play_turn(self):
        # Obsługuje ruch aktualnego gracza.
        current_player = self.players[self.turn % 2]
        while True:
            try:
                move = int(input(f"Player {current_player}'s turn (1-9): ")) - 1
                row, col = divmod(move, 3)
                if 0 <= row < 3 and 0 <= col < 3:
                    if self.board.is_cell_empty(row, col):
                        self.board.update_cell(row, col, current_player)
                        break
                    else:
                        print("Cell already taken, choose another.")
                else:
                    print("Invalid move. Please choose a number between 1 and 9.")
            except ValueError:
                print("Invalid input. Please enter a number between 1 and 9.")

    def play_game(self):
        # Rozpoczyna i zarządza główną pętlą gry.
        while True:
            self.board.print_board()
            self.play_turn()

            current_player = self.players[self.turn % 2]
            if self.board.check_winner(current_player):
                self.board.print_board()
                print(f"Player {current_player} wins!")
                break

            if self.board.is_full():
                self.board.print_board()
                print("It's a draw!")
                break

            self.turn += 1


if __name__ == "__main__":
    # Punkt wejścia do programu. Tworzy obiekt gry i uruchamia ją.
    game = Game()
    game.play_game()